"""HTTP cache implementation.
"""

import os
from contextlib import contextmanager
<<<<<<< HEAD
<<<<<<< HEAD
from typing import Iterator, Optional
=======
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23
=======
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23

from pip._vendor.cachecontrol.cache import BaseCache
from pip._vendor.cachecontrol.caches import FileCache
from pip._vendor.requests.models import Response

from pip._internal.utils.filesystem import adjacent_tmp_file, replace
from pip._internal.utils.misc import ensure_dir
<<<<<<< HEAD
<<<<<<< HEAD


def is_from_cache(response: Response) -> bool:
=======
=======
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23
from pip._internal.utils.typing import MYPY_CHECK_RUNNING

if MYPY_CHECK_RUNNING:
    from typing import Optional, Iterator


def is_from_cache(response):
    # type: (Response) -> bool
<<<<<<< HEAD
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23
=======
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23
    return getattr(response, "from_cache", False)


@contextmanager
<<<<<<< HEAD
<<<<<<< HEAD
def suppressed_cache_errors() -> Iterator[None]:
=======
def suppressed_cache_errors():
    # type: () -> Iterator[None]
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23
=======
def suppressed_cache_errors():
    # type: () -> Iterator[None]
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23
    """If we can't access the cache then we can just skip caching and process
    requests as if caching wasn't enabled.
    """
    try:
        yield
<<<<<<< HEAD
<<<<<<< HEAD
    except OSError:
=======
    except (OSError, IOError):
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23
=======
    except (OSError, IOError):
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23
        pass


class SafeFileCache(BaseCache):
    """
    A file based cache which is safe to use even when the target directory may
    not be accessible or writable.
    """

<<<<<<< HEAD
<<<<<<< HEAD
    def __init__(self, directory: str) -> None:
        assert directory is not None, "Cache directory must not be None."
        super().__init__()
        self.directory = directory

    def _get_cache_path(self, name: str) -> str:
=======
=======
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23
    def __init__(self, directory):
        # type: (str) -> None
        assert directory is not None, "Cache directory must not be None."
        super(SafeFileCache, self).__init__()
        self.directory = directory

    def _get_cache_path(self, name):
        # type: (str) -> str
<<<<<<< HEAD
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23
=======
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23
        # From cachecontrol.caches.file_cache.FileCache._fn, brought into our
        # class for backwards-compatibility and to avoid using a non-public
        # method.
        hashed = FileCache.encode(name)
        parts = list(hashed[:5]) + [hashed]
        return os.path.join(self.directory, *parts)

<<<<<<< HEAD
<<<<<<< HEAD
    def get(self, key: str) -> Optional[bytes]:
        path = self._get_cache_path(key)
        with suppressed_cache_errors():
            with open(path, "rb") as f:
                return f.read()

    def set(self, key: str, value: bytes) -> None:
=======
=======
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23
    def get(self, key):
        # type: (str) -> Optional[bytes]
        path = self._get_cache_path(key)
        with suppressed_cache_errors():
            with open(path, 'rb') as f:
                return f.read()

    def set(self, key, value):
        # type: (str, bytes) -> None
<<<<<<< HEAD
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23
=======
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23
        path = self._get_cache_path(key)
        with suppressed_cache_errors():
            ensure_dir(os.path.dirname(path))

            with adjacent_tmp_file(path) as f:
                f.write(value)

            replace(f.name, path)

<<<<<<< HEAD
<<<<<<< HEAD
    def delete(self, key: str) -> None:
=======
    def delete(self, key):
        # type: (str) -> None
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23
=======
    def delete(self, key):
        # type: (str) -> None
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23
        path = self._get_cache_path(key)
        with suppressed_cache_errors():
            os.remove(path)
