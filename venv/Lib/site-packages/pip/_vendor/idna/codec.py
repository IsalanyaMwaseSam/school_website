from .core import encode, decode, alabel, ulabel, IDNAError
import codecs
import re
<<<<<<< HEAD
<<<<<<< HEAD
from typing import Tuple, Optional

_unicode_dots_re = re.compile('[\u002e\u3002\uff0e\uff61]')
=======

_unicode_dots_re = re.compile(u'[\u002e\u3002\uff0e\uff61]')
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23
=======

_unicode_dots_re = re.compile(u'[\u002e\u3002\uff0e\uff61]')
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23

class Codec(codecs.Codec):

    def encode(self, data, errors='strict'):
<<<<<<< HEAD
<<<<<<< HEAD
        # type: (str, str) -> Tuple[bytes, int]
        if errors != 'strict':
            raise IDNAError('Unsupported error handling \"{}\"'.format(errors))

        if not data:
            return b"", 0
=======
=======
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23

        if errors != 'strict':
            raise IDNAError("Unsupported error handling \"{0}\"".format(errors))

        if not data:
            return "", 0
<<<<<<< HEAD
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23
=======
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23

        return encode(data), len(data)

    def decode(self, data, errors='strict'):
<<<<<<< HEAD
<<<<<<< HEAD
        # type: (bytes, str) -> Tuple[str, int]
        if errors != 'strict':
            raise IDNAError('Unsupported error handling \"{}\"'.format(errors))

        if not data:
            return '', 0
=======
=======
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23

        if errors != 'strict':
            raise IDNAError("Unsupported error handling \"{0}\"".format(errors))

        if not data:
            return u"", 0
<<<<<<< HEAD
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23
=======
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23

        return decode(data), len(data)

class IncrementalEncoder(codecs.BufferedIncrementalEncoder):
<<<<<<< HEAD
<<<<<<< HEAD
    def _buffer_encode(self, data, errors, final):  # type: ignore
        # type: (str, str, bool) -> Tuple[str, int]
        if errors != 'strict':
            raise IDNAError('Unsupported error handling \"{}\"'.format(errors))

        if not data:
            return "", 0

        labels = _unicode_dots_re.split(data)
        trailing_dot = ''
=======
=======
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23
    def _buffer_encode(self, data, errors, final):
        if errors != 'strict':
            raise IDNAError("Unsupported error handling \"{0}\"".format(errors))

        if not data:
            return ("", 0)

        labels = _unicode_dots_re.split(data)
        trailing_dot = u''
<<<<<<< HEAD
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23
=======
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23
        if labels:
            if not labels[-1]:
                trailing_dot = '.'
                del labels[-1]
            elif not final:
                # Keep potentially unfinished label until the next call
                del labels[-1]
                if labels:
                    trailing_dot = '.'

        result = []
        size = 0
        for label in labels:
            result.append(alabel(label))
            if size:
                size += 1
            size += len(label)

        # Join with U+002E
<<<<<<< HEAD
<<<<<<< HEAD
        result_str = '.'.join(result) + trailing_dot  # type: ignore
        size += len(trailing_dot)
        return result_str, size

class IncrementalDecoder(codecs.BufferedIncrementalDecoder):
    def _buffer_decode(self, data, errors, final):  # type: ignore
        # type: (str, str, bool) -> Tuple[str, int]
        if errors != 'strict':
            raise IDNAError('Unsupported error handling \"{}\"'.format(errors))

        if not data:
            return ('', 0)

        labels = _unicode_dots_re.split(data)
        trailing_dot = ''
        if labels:
            if not labels[-1]:
                trailing_dot = '.'
=======
=======
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23
        result = ".".join(result) + trailing_dot
        size += len(trailing_dot)
        return (result, size)

class IncrementalDecoder(codecs.BufferedIncrementalDecoder):
    def _buffer_decode(self, data, errors, final):
        if errors != 'strict':
            raise IDNAError("Unsupported error handling \"{0}\"".format(errors))

        if not data:
            return (u"", 0)

        # IDNA allows decoding to operate on Unicode strings, too.
        if isinstance(data, unicode):
            labels = _unicode_dots_re.split(data)
        else:
            # Must be ASCII string
            data = str(data)
            unicode(data, "ascii")
            labels = data.split(".")

        trailing_dot = u''
        if labels:
            if not labels[-1]:
                trailing_dot = u'.'
<<<<<<< HEAD
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23
=======
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23
                del labels[-1]
            elif not final:
                # Keep potentially unfinished label until the next call
                del labels[-1]
                if labels:
<<<<<<< HEAD
<<<<<<< HEAD
                    trailing_dot = '.'
=======
                    trailing_dot = u'.'
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23
=======
                    trailing_dot = u'.'
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23

        result = []
        size = 0
        for label in labels:
            result.append(ulabel(label))
            if size:
                size += 1
            size += len(label)

<<<<<<< HEAD
<<<<<<< HEAD
        result_str = '.'.join(result) + trailing_dot
        size += len(trailing_dot)
        return (result_str, size)
=======
        result = u".".join(result) + trailing_dot
        size += len(trailing_dot)
        return (result, size)
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23
=======
        result = u".".join(result) + trailing_dot
        size += len(trailing_dot)
        return (result, size)
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23


class StreamWriter(Codec, codecs.StreamWriter):
    pass

<<<<<<< HEAD
<<<<<<< HEAD

class StreamReader(Codec, codecs.StreamReader):
    pass


def getregentry():
    # type: () -> codecs.CodecInfo
    # Compatibility as a search_function for codecs.register()
    return codecs.CodecInfo(
        name='idna',
        encode=Codec().encode,  # type: ignore
        decode=Codec().decode,  # type: ignore
=======
=======
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23
class StreamReader(Codec, codecs.StreamReader):
    pass

def getregentry():
    return codecs.CodecInfo(
        name='idna',
        encode=Codec().encode,
        decode=Codec().decode,
<<<<<<< HEAD
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23
=======
>>>>>>> a9d900c1457080d90d61291d4e50f857aa62fa23
        incrementalencoder=IncrementalEncoder,
        incrementaldecoder=IncrementalDecoder,
        streamwriter=StreamWriter,
        streamreader=StreamReader,
    )
